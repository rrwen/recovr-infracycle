---
title: "Pedalling Forward: The Evolution of Dedicated Cycling Infrastructure in Canadian Cities from 2010 to 2022"
subtitle: "R Code for Figures and Tables"
author:
- "Konrad Samsel <konrad.samsel@mail.utoronto.ca>"
- "Richard Wen <richard.wen@utoronto.ca>"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
    pdf_document:
        toc: true
        toc_depth: 3
        highlight: zenburn
---

```{r metadata, include=FALSE, echo=FALSE}
## TITLE:       Bikeway Length Calculation Functions
## DESCRIPTION: Calculate length of segments using standardized dataset, includes verification dataframe and example use case
## CONTENTS:    Consists of length calculation functions
## PREPARED BY: Konrad Samsel (University of Toronto, DLSPH)
## CONTACT:     konrad.samsel@mail.utoronto.ca
## ALT CONTACT: Brice Kuimi PhD, Linda Rothman PhD (DLSPH)
## CREATED:     2023-06-05
## R VERSION (OLD):   2022.07.2 Build 576, R4.2.2
## R VERSION (NEW):   2023.06.16, R4.3.1
##
## LAST MODIFIED:     2024-02-04
## LAST MODIFIED BY:  Richard Wen
knitr::opts_chunk$set(warning = FALSE)
```

\newpage

# Libraries

Install R libraries if needed.

```{r lib-install, eval=FALSE}
install.packages("rmarkdown")
install.packages("bookdown")
install.packages("knitr")
install.packages("tidyverse")
install.packages("readxl")
install.packages("tidyr")
install.packages("stringr")
install.packages("jsonlite")
install.packages("dplyr")
install.packages("writexl")
install.packages("ggplot2")
install.packages("ggtext")
install.packages("grid")
install.packages("gridExtra")
```

Load R libraries.

```{r lib, warning=FALSE, message=FALSE}
library(tidyverse)
library(readxl)
library(tidyr)
library(stringr)
library(jsonlite)
library(dplyr)
library(writexl)
library(ggplot2)
library(ggtext)
library(grid)
library(gridExtra)
```

# Functions

Functions used in this code, functions are called later in the dataset, these functions are for calculating bikeway length.

## Function 1: Variable Generation, Called in Coder Function

THE following are functions used later in the code, do not alter unless needed.

* Overview: function to create a new base variable that includes last 2 numbers for the start and end year
* Intended Use: apply this function to create a new string, process output_columnbase_var to include years, this function is used in Function 2
* Data Types: INPUT: (STRING, NUMERIC, NUMERIC) / OUTPUT: (STRING)

```{r echo=FALSE}
# Syntax Example:
# 
# output_columnbase_var_pr <- create_new_string(output_columnbase_var, year_start_var, year_end_var)
```

```{r}
create_new_string <-
    function(output_columnbase_var,
             year_start_var,
             year_end_var) {
        new_string <-
            paste0(
                output_columnbase_var,
                "_",
                substr(as.character(year_start_var), 3, 4),
                substr(as.character(year_end_var), 3, 4)
            )
        return(new_string)
    }
```

## Function 2: Code Infrastructure

Create a list for each infrastructure type denoting the years when a given infrastructure was present in a given row(observation). 1 if true, else 0, list can be parsed for calculating length of given bikeway infrastructure types across the entire city.

Function mutates df and appends new columns

* Intended Use: this function takes several arguments:
    * df(df, function robust against NA and NULL values, but must convert "NA" into NA)
    * types of infrastructure (list of strings)
    * starting year for the calculation (num, format: ####)
    * ending year for the calculation (num, format: ####)
    * installation year (factor or numeric, format: ####)
    * installation type (factor or string(chr))
    * upgrade1 year (factor or numeric, format: ####)
    * upgrade1 type (factor or string(chr))
    * upgrade2 year (factor or numeric, format: ####)
    * upgrade2 type (factor or string(chr))
    * variable_base (string(chr))  
* RETURNS: list LEN ending_year - starting_year + 1 in new column for each category specified in type_of_infrastructure variable

```{r echo=FALSE}
# Syntax example
# 
# test_df_cal <- create_list_columns_check(
#     dataset_var,
#     infra_types_var,
#     year_start_var,
#     year_end_var,
#     "INST_YEAR",
#     "INST_TYPE_MAJ",
#     "UPGR1_YEAR",
#     "UPGR1_TTYPE_MAJ",
#     "UPGR2_YEAR",
#     "UPGR2_TYPE_MAJ",
#     output_columnbase_var
# )
# 
# Example Data Type for Input
# 
# dataset_var:
#     df,
#     infra_type:c("PL","PBL"),
#     start_year:2010,
#     end_year:2021,
#     install_year:df[1]=2012,
#     install_type: df[1]="None",
#     upgr1_year: df[1]=2015,
#     upgr1_type: df[1]="PL",
#     upgr2_year: df[1]=2017,
#     upgr2_type: df[1]="PBL",
#     variable_name_base="LIST_MAJOR"
# 
# Example Output data
# 
# 2 new columns added to
# 
# df ("LIST_MAJOR1021PL", "LIST_MAJOR1021PBL")
# where
# df$LIST_MAJOR1021PL[1]= c(10,10,70,70,70,41,41,70,70,70,70,70)
# and
# df$LIST_MAJOR1021PBL[1]= c(10,10,70,70,70,70,70,61,61,61,61,61)
# 
# Example for Function 2
# 
# example_function2 <- data.frame(
#    INST_YEAR = 2012,
#    INST_TYPE_MAJ = "None",
#    UPGR1_YEAR = 2015,
#    UPGR1_TYPE_MAJ = "PL",
#    UPGR2_YEAR = 2017,
#    UPGR2_TYPE_MAJ = "PBL"
#  )
#  
# # Call create_list_columns_check function
# print(create_list_columns_check(example_function2, c("PL","PBL"), 2010, 2021, "INST_YEAR", "INST_TYPE_MAJ", "UPGR1_YEAR", "UPGR1_TYPE_MAJ", "UPGR2_YEAR", "UPGR2_TYPE_MAJ", "ExampleBase"))
# 
# # Remove the example_function2 dataframe
# rm(example_function2)
```

```{r}
create_list_columns_check <- function(
        data,
        incl_infra_type = c("PBL", "BUF", "PL"),
        start_year = 2009,
        end_year = 2021,
        install_year = "INST_YR",
        install_type = "INST_MIN_HTYPE",
        upgr1_year = "UPGR1_YR",
        upgr1_type = "UPGR1_MIN_HTYPE",
        upgr2_year = "UPGR2_YR",
        upgr2_type = "UPGR2_MIN_HTYPE",
        variable_base = "LENMIN"
) {
    
    # Set base variable name to store infra types
    variable_name_base <- create_new_string(
        variable_base,
        start_year,
        end_year
    )
    
    # print(paste(
    #             "Evaluate From Year",
    #             start_year,
    #             "To Year",
    #             end_year,
    #             " / Corresponding base will be:",
    #             variable_name_base
    #         )
    #     )
        
    # Convert years to numeric
    start_year <- as.numeric(start_year)
    end_year <- as.numeric(end_year)
    install_year <- as.numeric(data[[install_year]], na.rm = TRUE)
    upgr1_year <- as.numeric(data[[upgr1_year]], na.rm = TRUE)
    upgr2_year <- as.numeric(data[[upgr2_year]], na.rm = TRUE)
    
    # Convert types to char
    install_type <- as.character(data[[install_type]], na.rm = TRUE)
    upgr1_type <- as.character(data[[upgr1_type]], na.rm = TRUE)
    upgr2_type <- as.character(data[[upgr2_type]], na.rm = TRUE)
    
    for (category in incl_infra_type) { # each infra type
        
        # Create new column to store infra types
        new_column_name <- paste0(variable_name_base, category)
        data[[new_column_name]] <- vector("list", nrow(data))
        
        # print(
        #     paste(
        #         "Infrastructure Type:",
        #         category,
        #         "/ Append new column: ",
        #         new_column_name,
        #         "/ Total Rows:",
        #         length(data[[new_column_name]])
        #     )
        # )
        
        for (i in 1:nrow(data)) { # each row
            year_list <- vector("numeric", end_year - start_year + 1)
            
            for (year_x in start_year:end_year) { # each list element
                
                # Set vars
                year_x_numeric <- as.numeric(year_x)
                
                # C1: inst year present and year_x occurs before inst year
                condition_1 <-
                    !is.na(install_year[i]) &
                    year_x_numeric < install_year[i]
                
                # C2: inst year/type and upgr year/type present
                # year_x occurs before upgr year and on/after install year
                # Also install type = category
                condition_2 <-
                    !is.na(install_year[i]) &
                    !is.na(upgr1_year[i]) & !is.na(upgr1_type[i]) &
                    year_x_numeric >= install_year[i] &
                    year_x_numeric < upgr1_year[i] &
                    install_type[i] %in% category
                
                # C3: inst year/type present but no upgr
                # year_x occurs on/after inst year and inst type = category
                condition_3 <-
                    !is.na(install_year[i]) & is.na(upgr1_year[i]) &
                    year_x_numeric >= install_year[i] &
                    install_type[i] %in% category
                
                # C4: upgr 1 and upgr 2 present
                # year_x occurs before 2nd upgrade and on/after 1st upgrade
                # Also upgr 1 type = category
                condition_4 <-
                    !is.na(upgr1_year[i]) &
                    !is.na(upgr1_type[i]) &
                    !is.na(upgr2_year[i]) & !is.na(upgr2_type[i]) &
                    year_x_numeric >= upgr1_year[i] &
                    year_x_numeric < upgr2_year[i] &
                    upgr1_type[i] %in% category
                
                # C5: upgr 1 present and no 2nd upgr
                # year_x occurs on/after 1st upgr
                # Also upgr 1 type = category
                condition_5 <-
                    !is.na(upgr1_year[i]) &
                    !is.na(upgr1_type[i]) &
                    is.na(upgr2_year[i]) & is.na(upgr2_type[i]) &
                    year_x_numeric >= upgr1_year[i] &
                    upgr1_type[i] %in% category
                
                # C6: 2nd upgr occurs
                # year_x occurs on/after upgr 2 year
                # Also upgr 2 type = category
                condition_6 <-
                    !is.na(upgr2_year[i]) &
                    !is.na(upgr2_type[i]) &
                    year_x_numeric >= upgr2_year[i] &
                    upgr2_type[i] %in% category 
                
                # Test conditions for each list element
                year_list[year_x_numeric - start_year + 1] <-
                    ifelse(condition_1, 10,
                           ifelse(condition_2, 21,
                               ifelse(condition_3, 31,
                                   ifelse(condition_4, 41,
                                       ifelse(condition_5, 51,
                                              ifelse(condition_6, 61, 70)
                                        )
                                   )
                               )
                           )
                    )
            }
            
            # After list tested, append list to row within designated column
            data[[new_column_name]][[i]] <- year_list 
        }
    }
    # print("#...Function Complete")
    # print("#...Check for warnings, columns for installation and 2 upgrades required. Check Several Random Cases Before Proceeding. If errors continue, contact author (Konrad)")
    # print("#...Each condition has different number at [1] to allow for function validation based on conditions, binary character at [2] indicates status of inclusion (0=No, 1=Yes)")
    return(data)
}
```

## Function 3: Calculate Length by Year

RETURNS new data frame for a given infrastructure type, 3 columns (year, number of bikeway elements eligible for inclusion, total length of these elements combined), each row denotes one year

* Intended Use: convert column created by function 2 into a new dataframe by parsing through the list present within each row, calculate total # of instances and total length
* Function parameters: data:
    * df
    * presence_column: list of numbers by row (e.g., c(10, 10, 10, 10, 10, 10, 10, 10, 21, 21, 51, 51)) where the 2nd number in each integer indicates presence/absence
    * length_column (number)
    * start year (integer, #### format)
* Data Types:
    * INPUT: (DF, COLUMN NAME(List of Numbers)
    * COLUMN_NAME(LENGTH)
    * NUMERIC(YEAR))
    * OUTPUT: (New DF)

```{r echo=FALSE}
# Syntax Example:
# 
# test_PBL <- calculate_len_by_year(test_df, "LENTEST_1023PBL", "segment_length", 2010)
```

```{r}
calculate_len_by_year <-function(
        data,
        presence_column = "LENMIN_0921PBL",
        length_column = "ATR_SEGMENT_LENGTH",
        start_year = 2009
) {
        if (!(all(lengths(data[[presence_column]]) == lengths(data[[presence_column]])[1]))) {
            print("Error: List Elements in Presence_Column Not Same Length")
            return(NULL)
        }
        start_year <- as.numeric(start_year)
        num_years <- length(data[[presence_column]][[1]])
        df_return <-
            data.frame(
                YEAR = numeric(num_years),
                NUM_ELEMENTS = numeric(num_years),
                TOTAL_LEN = numeric(num_years)
            )
        
        for (i in 1:num_years) {
            len_yr <- 0
            num_elements <- 0
            for (r in 1:nrow(data)) {
                if (as.integer(substr(data[[presence_column]][[r]][[i]], 2, 2)) == 1) {
                    len_yr <- len_yr + as.numeric(data[[length_column]][r])
                    num_elements <- num_elements + 1
                }
            }
            df_return[i, "YEAR"] <- start_year + i - 1
            df_return[i, "NUM_ELEMENTS"] <- num_elements
            df_return[i, "TOTAL_LEN"] <- len_yr
        }
        
        return(df_return)
    }
```

## Function 4: Calculate Lengths by Year and Infrastructure

Calculates segment lengths by year and infrastructure using functions 1-3.

```{r}
calc_len_infra <- function(
        df,
        year_start_var = 2009,
        year_end_var = 2021,
        output_columnbase_var = "LENMIN" # out prefix name
    ) {
    VAN_BIKE_LENCALC <- df
    VAN_BIKE_LENCALC <-
        VAN_BIKE_LENCALC[, c(
            #"ID_CITY",
            #"ATR_STATUS",
            #"ATR_ORIG_TYPE",
            #"DPR_ENTRY",
            #"DPR_EXCL_FLAG",
            "INST_YR",
            #"INST_MAJ_HTYPE",
            "INST_MIN_HTYPE",
            "UPGR1_YR",
            #"UPGR1_MAJ_HTYPE",
            "UPGR1_MIN_HTYPE",
            "UPGR2_YR",
            #"UPGR2_MAJ_HTYPE",
            "ATR_SEGMENT_LENGTH"
        )]
    
    # Data type conversions
    for (i in c("INST_YR", "UPGR1_YR", "UPGR2_YR")) {
        VAN_BIKE_LENCALC[[i]] <- as.integer(VAN_BIKE_LENCALC[[i]])
        VAN_BIKE_LENCALC[[i]] <- as.character(VAN_BIKE_LENCALC[[i]])
    }
    
    # PROCESS FOR MINOR CATEGORIES (minor = 3 types: painted lane, buffered lane, and cycle track, denoted as PL, BUF, and PBL respectively).
    #Function applied for the study period 2009-2021
    
    # REQUIRED PRE-PROCESSING ======================================================
    
    #REMOVE EXLCUDED SEGMENTS BASED ON PREDETERMINED CATEOGIRICAL VARIABLE
    if ("DPR_ENTRY" %in% colnames(df)) {
        VAN_BIKE_LENCALC$DPR_ENTRY <- df$DPR_ENTRY
        VAN_BIKE_LENCALC <- subset(VAN_BIKE_LENCALC, DPR_ENTRY == "COMPLETE")
    }
    
    #MUST SET MISSING VALUES TO TYPE = NA
    VAN_BIKE_LENCALC[VAN_BIKE_LENCALC == "NA"] <- NA
    
    #variable definitions - THREE CATEGORIES, 2009-2021 ============================
    dataset_var <- VAN_BIKE_LENCALC  #name of dataset
    length_var <- "ATR_SEGMENT_LENGTH"    #name of length variable (m)
    infra_types_var <-
        c("PBL", "BUF", "PL")     #infrastructure types to be checked, make sure they match the types in a given column
    
    ############ APPLY CODER FUNCTION ==============================================
    # before running, ensure INST_YR, UPGR1_YR, and UPGR2_YR are of type numeric,
    VAN_BIKE_LENMIN <-
        create_list_columns_check(
            dataset_var,
            infra_types_var,
            year_start_var,
            year_end_var,
            "INST_YR",
            "INST_MIN_HTYPE",
            "UPGR1_YR",
            "UPGR1_MIN_HTYPE",
            "UPGR2_YR",
            "UPGR2_MIN_HTYPE",
            output_columnbase_var
        )
    
    ########### APPLY PARSER FUNCTION - copy names outputted in console when running coder function
    
    syear <- str_sub(year_start_var, -2)
    eyear <- str_sub(year_end_var, -2)
    
    VAN_MIN_PBL <- calculate_len_by_year(
        VAN_BIKE_LENMIN,
        paste0(output_columnbase_var, "_", syear, eyear, "PBL"),
        length_var,
        year_start_var
    )
    
    VAN_MIN_BUF <- calculate_len_by_year(
        VAN_BIKE_LENMIN,
        paste0(output_columnbase_var, "_", syear, eyear, "BUF"),
        length_var,
        year_start_var
    )
    
    VAN_MIN_PL <- calculate_len_by_year(
        VAN_BIKE_LENMIN,
        paste0(output_columnbase_var, "_", syear, eyear, "PL"),
        length_var,
        year_start_var
    )
    
    # Merge Datasets
    VAN_LENGTH_MINRESULTS <-
        merge(VAN_MIN_PBL,
              VAN_MIN_BUF,
              by = "YEAR",
              suffixes = c("_PBL", "_BUF"))
    VAN_LENGTH_MINRESULTS <-
        merge(VAN_LENGTH_MINRESULTS,
              VAN_MIN_PL,
              by = "YEAR",
              suffixes = c("", "_PL"))
    names(VAN_LENGTH_MINRESULTS)[names(VAN_LENGTH_MINRESULTS) == "NUM_ELEMENTS"] <-
        "NUM_ELEMENTS_PL"
    names(VAN_LENGTH_MINRESULTS)[names(VAN_LENGTH_MINRESULTS) == "TOTAL_LEN"] <-
        "TOTAL_LEN_PL"
    
    #Calculate Total Infrastructure per year
    VAN_LENGTH_MINRESULTS$GRAND_TOTAL <-
        as.numeric((VAN_LENGTH_MINRESULTS$TOTAL_LEN_PBL) + (VAN_LENGTH_MINRESULTS$TOTAL_LEN_BUF) + (VAN_LENGTH_MINRESULTS$TOTAL_LEN_PL)
        )
    
    #create new dataset for km unit (from lengths in m)
    merged_km_min <- VAN_LENGTH_MINRESULTS
    merged_km_min$TOTAL_LEN_PBL <- (merged_km_min$TOTAL_LEN_PBL) / 1000
    merged_km_min$TOTAL_LEN_BUF <- (merged_km_min$TOTAL_LEN_BUF) / 1000
    merged_km_min$TOTAL_LEN_PL <- (merged_km_min$TOTAL_LEN_PL) / 1000
    merged_km_min$GRAND_TOTAL <- (merged_km_min$GRAND_TOTAL) / 1000
    
    #convert data into long form
    merged_km_min_long <- merged_km_min %>%
        pivot_longer(
            cols = c(TOTAL_LEN_PL, TOTAL_LEN_BUF, TOTAL_LEN_PBL),
            names_to = "Infrastructure_Type",
            values_to = "Total_Length"
        ) #create data into long form
    
    #set factor levels to determine appropriate order in graph
    merged_km_min_long$Infrastructure_Type <-
        factor(
            merged_km_min_long$Infrastructure_Type,
            levels = c("TOTAL_LEN_PBL", "TOTAL_LEN_BUF", "TOTAL_LEN_PL")
        ) #set
    
    # Return the formatted data
    out <- merged_km_min_long
    return(out)
}
```

## Function 5: Plot Lengths by Year and Infrastructure

Plots an area chart from data prepared using function 4 to show the segment lengths for different years and infrastructure types.

```{r}
plot_len_infra <- function(
        df,
        title = "",
        xlabel = "",
        ylabel = "",
        startyear = 2009,
        endyear = 2022,
        year_col = "YEAR",
        len_col = "Total_Length",
        cat_col = "Infrastructure_Type"
) {
  len_max <- max(df[[len_col]], na.rm = TRUE)
  out <- ggplot(
    df,
    aes(
        x = .data[[year_col]],
        y = .data[[len_col]],
        fill = .data[[cat_col]],
        order = dplyr::desc(.data[[cat_col]])
    )
  ) +
  geom_area(colour = NA, alpha = 0.7) +
  scale_fill_manual(
      values = c("#DFEBF7", "#A0CAE0", "#3683BB"),
      labels = c("Cycle Track", "Buffered Lane", "Painted Lane")
  ) +
  geom_line(position = "stack", size = 0.2) +
  geom_vline(xintercept = 2019,
             color = "black",
             linetype = "dashed") +
  geom_segment(
      aes(
          x = 2009,
          y = 0,
          xend = 2009,
          yend = 50,
          color = "#bb0000",
          hjust = 0.15
      )
  ) +
  geom_segment( # 50km red triangle point down
      aes(
          x = 2009,
          y = 50.01 - (len_max * 0.05),
          xend = 2009,
          yend = 50 - (len_max * 0.05),
          color = "#bb0000",
          hjust = 0.15
      ),
      arrow = arrow(
          length = unit(0.03, "npc"),
          ends = "last",
          type = "closed"
      )
  ) +
  geom_segment( # 50km red triangle point up
      aes(
          x = 2009,
          y = (len_max * 0.05) - 0.01,
          xend = 2009,
          yend = (len_max * 0.05),
          color = "#bb0000",
          hjust = 0.15
      ),
      arrow = arrow(
          length = unit(0.03, "npc"),
          ends = "last",
          type = "closed"
      )
  ) +
  annotate(
      "text",
      x = 2009,
      y = 50,
      label = "50km",
      color = "#bb0000",
      hjust = -0.225
  ) +
  labs(x = xlabel,
       y = ylabel,
       fill = "Infrastructure Type"
  ) +
  ggtitle(
      bquote(underline(.(title)))
  ) +
  guides(
      fill = guide_legend(
          reverse = F,
          override.aes = list(
              alpha = 0.7,
              color = NA,
              shape = NA
          )
      ),
      color = "none"
  ) +
  scale_x_continuous(
      breaks = seq(startyear, endyear, by = 1),
      labels = seq(startyear, endyear, by = 1),
      limits = c(startyear, endyear)
  ) +
  theme_minimal() +
  theme(
      plot.margin = unit(c(5,5,5,5), "points"))
  return(out)
}
```

## Function 6: Plot Lengths by Year and Road Type

Plots an area chart from to show the segment lengths for different years and road types.

```{r}
plot_len_road <- function(
        df,
        title = "",
        xlabel = "",
        ylabel = "",
        startyear = 2009,
        endyear = 2022,
        year_col = "YEAR",
        len_col = "Total_Length",
        cat_col = "Infrastructure_Type"
) {
  len_max <- max(df[[len_col]], na.rm = TRUE)
  out <- ggplot(
    df,
    aes(
        x = .data[[year_col]],
        y = .data[[len_col]],
        fill = .data[[cat_col]],
        order = dplyr::desc(.data[[cat_col]])
    )
  ) +
  geom_area(colour = NA, alpha = 0.7) +
  scale_fill_manual(
      values = c("#DFEBF7", "#A0CAE0", "#3683BB"),
      labels = c("Cycle Track", "Buffered Lane", "Painted Lane")
  ) +
  geom_line(position = "stack", size = 0.2) +
  geom_vline(xintercept = 2019,
             color = "black",
             linetype = "dashed") +
  geom_segment(
      aes(
          x = 2009,
          y = 0,
          xend = 2009,
          yend = 50,
          color = "#bb0000",
          hjust = 0.15
      )
  ) +
  geom_segment( # 50km red triangle point down
      aes(
          x = 2009,
          y = 50.01 - (len_max * 0.05),
          xend = 2009,
          yend = 50 - (len_max * 0.05),
          color = "#bb0000",
          hjust = 0.15
      ),
      arrow = arrow(
          length = unit(0.03, "npc"),
          ends = "last",
          type = "closed"
      )
  ) +
  geom_segment( # 50km red triangle point up
      aes(
          x = 2009,
          y = (len_max * 0.05) - 0.01,
          xend = 2009,
          yend = (len_max * 0.05),
          color = "#bb0000",
          hjust = 0.15
      ),
      arrow = arrow(
          length = unit(0.03, "npc"),
          ends = "last",
          type = "closed"
      )
  ) +
  annotate(
      "text",
      x = 2009,
      y = 50,
      label = "50km",
      color = "#bb0000",
      hjust = -0.225
  ) +
  labs(x = xlabel,
       y = ylabel,
       fill = "Infrastructure Type"
  ) +
  ggtitle(
      bquote(underline(.(title)))
  ) +
  guides(
      fill = guide_legend(
          reverse = F,
          override.aes = list(
              alpha = 0.7,
              color = NA,
              shape = NA
          )
      ),
      color = "none"
  ) +
  scale_x_continuous(
      breaks = seq(startyear, endyear, by = 1),
      labels = seq(startyear, endyear, by = 1),
      limits = c(startyear, endyear)
  ) +
  theme_minimal() +
  theme(
      plot.margin = unit(c(5,5,5,5), "points"))
  return(out)
}
```



```{r funct, include=FALSE, results=FALSE, echo=FALSE}
# Testing
# Verify entire process by making a custom dataset.

# Create an empty dataframe with the desired column names
testcase_df <- data.frame(INST_YR = numeric(),
                          INST_TYPE = character(),
                          UPGR1_YR = numeric(),
                          UPGR1_TYPE = character(),
                          UPGR2_YR = numeric(),
                          UPGR2_TYPE = character(),
                          LENGTH = numeric(),
                          stringsAsFactors = FALSE)

# Add data to the dataframe by appending rows
testcase_df <- rbind(testcase_df,
                     data.frame(INST_YR = c(1990, 2010, 2011, 2015, 2020, 2021),
                                INST_TYPE = c("PL", "PATH", "BUF", "None", "PBL", "PBL"),
                                UPGR1_YR = c(NA, 2012, 2020, 2016, 2021, NA),
                                UPGR1_TYPE = c(NA, "PL", "PBL", "PL", "PBL", NA),
                                UPGR2_YR = c(NA, 2014, NA, 2020, NA, NA),
                                UPGR2_TYPE = c(NA, "BUF", NA, "PBL", NA, NA),
                                LENGTH = c(10, 50, 100, 500, 1000, 5000)
                     ))

# Check the dataframe
testcase_df

#Example usage
#FORMAT testcase_df_fun1  <- create_list_columns_check(dataset_var, infra_types_var, year_start_var, year_end_var, "INST_YR", "INST_MAJ_HTYPE", "UPGR1_YR", "UPGR1_MAJ_HTYPE", "UPGR2_YR", "UPGR2_MAJ_HTYPE", output_columnbase_var)

testcase_df_fun1 <- create_list_columns_check(testcase_df, c("PL", "BUF", "PBL"), 2010, 2021, "INST_YR", "INST_TYPE", "UPGR1_YR", "UPGR1_TYPE", "UPGR2_YR", "UPGR2_TYPE", "TEST_FUN1")

#parse through data with parser function
testcase_df_fun2_pbl <- calculate_len_by_year(testcase_df_fun1, "TEST_FUN1_1021PBL", "LENGTH", 2010)
testcase_df_fun2_pl <- calculate_len_by_year(testcase_df_fun1, "TEST_FUN1_1021PL", "LENGTH", 2010)
testcase_df_fun2_buf <- calculate_len_by_year(testcase_df_fun1, "TEST_FUN1_1021BUF", "LENGTH", 2010)

#view data frames for each infrastructure type
testcase_df_fun2_pl
testcase_df_fun2_buf
testcase_df_fun2_pbl

#merge newly created dataframes
verify_merge_df <- merge(testcase_df_fun2_pl, testcase_df_fun2_buf, by = "YEAR", suffixes = c("_pl", "_buf"))
verify_merge_df <- merge(verify_merge_df, testcase_df_fun2_pbl, by = "YEAR", suffixes = c("", "_pbl"))

#view newly merged dataframe
verify_merge_df

#manually verify
#function verified. Expected values are given for boh functions, process validated for situations when data parameteres meet expeced conditions set forth in the Dataset. 
testcase_df_fun1
verify_merge_df
```

# Data

## Vancouver Data

```{r vanc-data}

# Load raw data
vanc_bikeways <- read_csv("../data/vancouver_bikeways_2009_2022_v1.csv")
vanc_roads <- read_csv("../data/vancouver_roads_2009_2022_v1.csv")

# Combine raw data
vanc <- vanc_bikeways %>%
	select(
		ID_DATAENTRY,
		INST_YR,
		INST_TYPE,
		INST_MIN_HTYPE,
		UPGR1_YR,
		UPGR1_MIN_HTYPE,
		UPGR2_YR,
		UPGR2_MIN_TYPE,
		ATR_SEGMENT_LENGTH
	) %>%
	left_join(
		vanc_roads %>% select(
			ID_DATAENTRY,
			ATR_SEGMENT_TYPE
		),
		by = "ID_DATAENTRY"
	) %>%
	rename(UPGR2_MIN_HTYPE = UPGR2_MIN_TYPE)
vanc
```
## Calgary Data

```{r calg-data}

# Load raw data
calg_bikeways <- read_csv("../data/calgary_bikeways_2009_2022_v1.csv")
calg_roads <- read_csv("../data/calgary_roads_2009_2022_v1.csv")

# Combine raw data
calg <- calg_bikeways %>%
    select(
		SHAPE_ID,
		INST_YR,
		INST_TYPE,
		INST_MIN_HTYPE,
		UPGR1_YR,
		UPGR1_MIN_HTYPE,
		UPGR2_YR,
		UPGR2_MIN_HTYPE,
		ATR_SEGMENT_LENGTH
	) %>%
	left_join(
		calg_roads %>% select(
			shape_id,
			ctp_class
		),
		by = join_by(SHAPE_ID == shape_id)
	) %>%
	rename(
		ID = SHAPE_ID,
		ATR_SEGMENT_TYPE = ctp_class
	)
calg
```

## Toronto Data

```{r toron-data}

# Load raw data
toron_bikeways <- read_csv("../data/toronto_bikeways_2009_2022_v1.csv")
toron_roads <- read_csv("../data/toronto_roads_2009_2022_v1.csv")

# Combine raw data
toron <- toron_bikeways %>%
    select(ID_OID,
           INST_YR,
           INST_TYPE,
           INST_MIN_HTYPE,
    	   UPGR1_YR,
    	   UPGR1_MIN_HTYPE,
    	   UPGR2_YR,
    	   UPGR2_MIN_HTYPE,
           ATR_SEGMENT_LENGTH
    ) %>%
	left_join(
		toron_roads %>% select(
			OID_,
			FEATURE36
		),
		by = join_by(ID_OID == OID_)
	) %>%
	rename(
		ID = ID_OID,
		ATR_SEGMENT_TYPE = FEATURE36
	)
toron
```

# Figures

## Figure 2: Changes in dedicated cycling infrastructure between 2009 and 2022 for Vancouver, Calgary, and Toronto by infrastructure category.

Assessed using roadway centreline-km, with infrastructure classifications determined by the most protective element present along each road segment. 

```{r fig.width=8.5, fig.height=11}

# Combine all cities for plotting
vanc_plot_infra <- calc_len_infra(vanc, 2009, 2021) %>%
    plot_len_infra(title = "Vancouver, Canada") +
    theme(plot.margin = unit(c(15,5,5,5), "point"))
calg_plot_infra <- calc_len_infra(calg, 2009, 2022) %>%
    plot_len_infra(title = "Calgary, Canada")
toron_plot_infra <- calc_len_infra(toron, 2009, 2022) %>%
    plot_len_infra(title = "Toronto, Canada")

# Plot per city
grid.arrange(
    vanc_plot_infra,
    calg_plot_infra,
    toron_plot_infra,
    ncol = 1,
    top = textGrob(
        "Roadways with Dedicated Cycling Infrastructure",
        gp = gpar(fontsize=18)
    ),
    bottom = textGrob(
        "Years (2009-2022)",
        gp = gpar(fontsize=14)
    ),
    left = textGrob(
        "Total Length (Centreline km)",
        gp = gpar(fontsize=14),
        rot = 90
    ),
    vp = viewport(
        width = 0.95,
        height = 0.95
    )
)
```

# Supplementary Figures

## Supplementary Figure 4: Changes in dedicated cycling infrastructure between 2009 and 2021 for the Municipality of Vancouver, CA

By (A) roadway classification, and (B) infrastructure distribution within each road class. Assessed using roadway centreline-km, with infrastructure classification determined by the most protective element present along each road segment.

```{r}

# Recode segments to one of art, coll, or lane
vanc_plot_roads <- vanc %>%
    mutate(ATR_ROAD_TYPE = case_when(
        ATR_SEGMENT_TYPE %in% c( # arterial equiv
        	"Arterial"
        ) ~ "Arterial",
        ATR_SEGMENT_TYPE %in% c( # collector equiv
        	"Collector",
        	"Secondary Arterial"
        ) ~ "Collector",
        ATR_SEGMENT_TYPE %in% c( # local equiv
        	"Lane",
        	"Residential",
        	"Leased",
        	"Recreational"
        ) ~ "Local",
        .default = ATR_SEGMENT_TYPE
    ))
```

## Toronto, CA

```{r}

# Recode segments to one of art, coll, or lane
toron_plot_roads <- toron %>%
    mutate(ATR_ROAD_TYPE = case_when(
        ATR_SEGMENT_TYPE %in% c( # arterial equiv
        	"Major Arterial",
        	"Major Arterial Ramp",
        	"Minor Arterial"
        ) ~ "Arterial",
        ATR_SEGMENT_TYPE %in% c( # collector equiv
        	"Collector"
        ) ~ "Collector",
        ATR_SEGMENT_TYPE %in% c(  # local equiv
        	"Local",
        	"Other"
        ) ~ "Local",
        .default = ATR_SEGMENT_TYPE
    ))
```

## Calgary, CA

```{r}

# Recode segments to one of art, coll, or lane
calg_plot_roads <- calg %>%
    mutate(ATR_ROAD_TYPE = case_when(
        ATR_SEGMENT_TYPE %in% c( # arterial equiv
        	"Arterial Street",
        	"Industrial Arterial",
        	"Local Arterial",
        	"Parkway",
        	"Urban Boulevard"
        ) ~ "Arterial",
        ATR_SEGMENT_TYPE %in% c( # collector equiv
        	"Neighbourhood Boulevard",
        	"Collector",
        	"Primary Collector",
        	"Skeletal Road"
        ) ~ "Collector",
        ATR_SEGMENT_TYPE %in% c( # local equiv
        	"Access Route",
        	"Residential Street",
        	"Activity Center Street",
        	"Historic Road Allowance",
        	"Lanes (Alleys)",
        	"Industrial Street"
        ) ~ "Local",
        .default = ATR_SEGMENT_TYPE
    ))
```

# Appendix

## R Version

R and RMarkdown in RStudio was used to generate this document.

```{r echo=FALSE}
version
```

## R Code

The R script below runs all the code in this document.

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```
