---
title: "Pedalling Forward: The Evolution of Dedicated Cycling Infrastructure in Canadian Cities from 2010 to 2022"
subtitle: "R Code for Figures and Tables"
author:
- "Richard Wen <richard.wen@utoronto.ca>"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
    pdf_document:
        toc: true
        toc_depth: 3
        highlight: zenburn
---

```{r metadata, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(warning = FALSE)
```

\newpage

# Libraries

Install R libraries if needed.

```{r lib-install, eval=FALSE}
install.packages("rmarkdown")
install.packages("bookdown")
install.packages("knitr")
install.packages("tidyverse")
install.packages("glue")
install.packages("readxl")
install.packages("ggtext")
install.packages("grid")
install.packages("gridExtra")
install.packages("scales")
install.packages("ggrepel")
```

Load R libraries.

```{r lib, warning=FALSE, message=FALSE}
library(tidyverse)
library(ggtext)
library(ggrepel)
library(glue)
library(grid)
library(gridExtra)
library(readxl)
```

# Functions

## Calculate Yearly Road Length

The following function calculates yearly road lengths by infrastructure type using cumulative sums and filling in missing years and types.

For a given infrastructure type, the total road length for a given year is expressed below:

$$
length_{year,type} = f(year,type) = \sum_{i=year_{min}}^{year}l_{i, type}
$$

Where:

* $year$ is the given year
* $type$ is the infrastructure type
* $year_{min}$ is the earliest year available in the data
* $l_{i,type}$ is the road length $l$ for previous years $i$ and infrastructure $j$
* $l_{i,type}$ is set to 0 if there is no data

```{r}

#' Calculate Yearly Road Lengths By Infrastructure Type
#'
#' @param df A data.frame with three columns containing the year, type, and road lengths.
#' @param year_col The name (char) or index (int) of the column containing the years.
#' @param type_col The name (char) or index (int) of the column containing the infrastructure type
#' @param len_col The name (char) or index (int) of the column containing the road lengths.
#' @param out_col The name (char) of the column containing the calculated yearly road lengths by type.
#'
#' @return A data.frame with three columns containing the year, type, and calculated yearly road lengths by type.
#' @export
#'
calc_yearly_len <- function(
		df,
		year_col = "install_year",
		type_col = "install_type",
		len_col = "segment_len",
		out_col = "len"
	) {
	
	# Convert data types
	df[[year_col]] <- as.integer(df[[year_col]])
	df[[type_col]] <- as.character(df[[type_col]])
	df[[len_col]] <- as.numeric(df[[len_col]])
	
	# Remove rows with empty type
	out <- df %>% filter(
		!is.na(.data[[type_col]])
	)
	
	# Add dummy len for each type and year combo
	# Covers cases where type and year combo does not exist
	# E.g. No new PL installs in 2021, hence a record PL in 2021 does not exist
	type_uniq <- unique(out[[type_col]])
	type_n <- length(type_uniq)
	year_uniq <- min(out[[year_col]], na.rm = TRUE):max(out[[year_col]], na.rm = TRUE)
	year_n <- length(year_uniq)
	out <- out %>% add_row(
		!!year_col := rep(year_uniq, each = type_n),
		!!type_col := rep(type_uniq, year_n),
		!!len_col := rep(0, type_n * year_n)
	)
	
	# Calc cumsum for each non-empty type ordered by year
	out <- out %>%
		arrange(.data[[year_col]]) %>%
		group_by(.data[[type_col]]) %>%
		mutate(
			!!out_col := cumsum(.data[[len_col]])
		)

	# Get the last cumsum for each year and type
	out <- out %>%
		group_by(.data[[year_col]], .data[[type_col]]) %>%
		arrange(desc(row_number())) %>%
		slice(1)
	
	# Return only the columns spec
	out <- out %>% select(c(
			year_col,
			type_col,
			out_col
		))
	return(out)
}
```

## Calculate Yearly Adjusted Road Length

The following function calculates yearly adjusted road lengths by infrastructure type using cumulative sums and filling in missing years and types.

For a given infrastructure type, the total adjusted road length for a given year is expressed below:

$$
length_{year,type}^{install} + length_{year,type}^{change_i} - length_{year,type}^{replacement_i}
$$
Where:

* $length_{year,type}^{install}$ are the yearly cumulative road lengths for an infrastructure $type$ installation
* $length_{year,type}^{change_i}$ are the yearly cumulative road lengths for an infrastructure $type$ change in order $i$
* $length_{year,type}^{replacement_i}$ are the yearly cumulative road lengths for an infrastructure $type$ replaced by change in order $i$

```{r}

#' Calculate Yearly Adjusted Road Lengths By Infrastructure Type
#'
#' @param df A data.frame with three columns containing the year, type, and road lengths.
#' @param year_cols A vector of the names (char) or indices (int) of the columns containing the years of installations followed by infrastructure changes in order.
#' @param type_cols A vector of the names (char) or indices (int) of the columns containing the infrastructure types of installations followed by infrastructure changes in order.
#' @param type_col The name (char) of the column containing the type.
#' @param len_cols A vector of the names (char) or indices (int) of the columns containing the road lengths of installations followed by infrastructure changes in order.
#' @param out_cols The name (char) of the column containing the calculated yearly road lengths by type.
#' @param out_col The name (char) of the column containing the calculated yearly adjusted road lengths by type.
#' @param repl_suffix A suffix (char) to append to the columns representing the road lengths of replaced infrastructure types from changes.
#' 
#' @return A data.frame with columns containing the year, type, cumulative road lengths of installations, changes, and replacements, and calculated yearly adjusted road lengths by type.
#' @export
#'
calc_yearly_adj_len <- function(
		df,
		year_cols = c("install_year", "upgrade1_year", "upgrade2_year"),
		type_cols = c("install_type", "upgrade1_type", "upgrade2_type"),
		type_col = "type",
		len_cols = "segment_len",
		out_cols = c("install_len", "upgrade1_len", "upgrade2_len"),
		out_col = "adj_len",
		repl_suffix = "_replaced"
	) {
	
	# Convert len_col if char
	len_cols <- rep(len_cols, length(year_cols))
	
	# Check cols same size
	year_cols_n <- length(year_cols)
	type_cols_n <- length(type_cols)
	len_cols_n <- length(len_cols)
	out_cols_n <- length(out_cols)
	if (length(unique(c(year_cols_n, type_cols_n, len_cols_n, out_cols_n))) != 1) {
		stop(glue(
			"The arguments 'year_cols' ({year_cols_n}), 'type_cols' ({type_cols_n}), 'len_cols' ({len_cols_n}), and 'out_cols' ({out_cols_n}) must be the same length."
		))
	}
	
	# Calc yearly lens by infra type per install or change
	out <- list()
	for (i in 1:length(year_cols)) {
		
		# Get year, type, and len cols
		ycol <- year_cols[[i]]
		tcol <- type_cols[[i]]
		lcol <- len_cols[[i]]
		ocol <- out_cols[[i]]
		
		# Calc yearly len for install or change
		out <- append(
			out,
			calc_yearly_len(
				df,
				year_col = ycol,
				type_col = tcol,
				len_col = lcol,
				out_col = ocol
			) %>%
				rename(
					"year" := !!ycol,
					"type" := !!tcol
				) %>% list
		)
		
		# Calc yearly len for replacement
		if (i > 1) {
			
			# Get repl cols
			tcol_repl <- type_cols[[i - 1]]
			lcol_repl <- len_cols[[i - 1]]
			
			# Filter for repl records only where type is not eq to change type
			df_repl <- df %>% filter(.data[[tcol]] != .data[[tcol_repl]])
			
			# Calc repl len if there are any changes
			has_change <- !is.na(df_repl[[tcol]]) %>% all 
			if (has_change) {
				out <- append(
					out,
					calc_yearly_len(
						df_repl,
						year_col = ycol,
						type_col = tcol_repl,
						len_col = lcol_repl,
						out_col = glue("{ocol}{repl_suffix}")
					) %>%
					rename(
						"year" := !!ycol,
						"type" := !!tcol_repl
					) %>% list
				)
			}
		}
	}
	
	# Combine all lens in list to single df
	out <- out %>%
		reduce(
			left_join, by = c("year", "type")
		) %>%
		ungroup()
	
	# Create template for change and repl cols
	change_cols <- paste0(out_cols[2:out_cols_n])# change cols
	change_cols <- c(change_cols, paste0(out_cols[2:out_cols_n], repl_suffix)) # repl cols
	change_cols_add <- rep(0, length(change_cols)) # set default vals
	names(change_cols_add) <- change_cols
	
	# Add change and repl cols set to 0 if not present
	out <- out %>% add_column(
		!!!change_cols_add[setdiff(names(change_cols_add), names(.))]
	)
	
	# Set NA to 0
	out <- out %>% mutate(
		across(everything(), ~replace_na(., 0))
	)
	
	# Calc yearly adj lens by infra type
	out <- out %>%
		mutate( # added len by infra types due to install or changes
			!!out_col := reduce(across(all_of(out_cols)), `+`)
		) %>%
		mutate( # removed len by infra types due to replacements
			!!out_col := .data[[out_col]] - reduce(
				across(all_of(
					paste0(out_cols[2:out_cols_n], repl_suffix)
				)),
				`-`
			)
		)
	
	# Rename type col
	out <- out %>% rename(!!type_col := type)
	return(out)
}
```

## Plot Lengths by Year for Generic Types

Plots an area chart showing the cumulative road lengths by a user-defined type for each year.

This is a generic function for user-defined types such as infrastructure or road types.

```{r}

#' Plot Yearly Road Lengths By Type
#'
#' @param df A data.frame with three columns containing the year, type, and road lengths.
#' @param title The title (char) of the plot.
#' @param title_underline Set to TRUE to underline the title.
#' @param x_title The title (char) of the x-axis.
#' @param y_title The title (char) of the y-axis.
#' @param legend_title The title (char) of the legend.
#' @param year_col The name (char) or index (int) of the column containing the years.
#' @param year_start The minimum year (int) to display.
#' @param year_end The maximum year (int) to display.
#' @param len_col The name (char) or index (int) of the column containing the road lengths.
#' @param type_col The name (char) or index (int) of the column containing the type.
#' @param type_filter A vector (char) of types to remove fomr the plot.
#' @param type_recode A named vector (char) of names representing types and values representing the values to replace each type with.
#' @param line_50km Set to TRUE to draw the 50 km red reference line.
#' @param line_year Set to a year (int) to draw a reference line for a year. If FALSE, a line will not be drawn.
#' @param color_low The bottom color (char) of the type.
#' @param color_high The top color (char) of the type.
#' @return An area ggplot of the cumulative yearly road lengths by type.
#' @export
#'
plot_yearly_len <- function(
        df,
        title = "",
        title_underline = TRUE,
        x_title = "",
        y_title = "",
        legend_title = "Type",
        year_col = "year",
        year_start = FALSE,
        year_end = FALSE,
        len_col = "adj_len",
        type_col = "type",
        type_filter = c(),
        type_recode = c(),
        line_50km = FALSE,
        line_year = FALSE,
        color_low = "#DFEBF7",
        color_high = "#3683BB"
) {
	
	# Filter to start and end years
	if (year_start > 0) {
		df <- df %>% filter(
			.data[[year_col]] >= year_start
		)
	}
	if (year_end > 0) {
		df <- df %>% filter(
			.data[[year_col]] <= year_end
		)
	}
	
	# Filter out particular infrastructure types
	if (length(type_filter) > 0) {
		df <- df %>% filter(
			!.data[[type_col]] %in% type_filter
		)
	}
	
	# Recode and reorder category types
	if (length(type_recode) > 0) {
		
		# Reorder category types
		type_uniq <- unique(df[[type_col]])
		type_reorder <- names(type_recode)
		type_reorder <- c(type_reorder, type_uniq[!type_uniq %in% type_reorder])
		df[[type_col]] <- factor(df[[type_col]], levels = type_reorder)
		
		# Recode category types
		df[[type_col]] <- recode(df[[type_col]], !!!type_recode)
	}
	
	# Create fill colors
	type_n <- length(type_uniq)
	type_colors <- scales::seq_gradient_pal(
		color_low,
		color_high
	)(seq(0, 1, length.out = type_n))
	
	# Create base area plot with legend and labels
	len_max <- max(df[[len_col]], na.rm = TRUE)
	year_max <- max(df[[year_col]], na.rm = TRUE)
	out <- ggplot(
		df,
		aes(
			x = .data[[year_col]],
			y = .data[[len_col]],
			fill = .data[[type_col]],
			order = desc(.data[[type_col]])
		)
	) +
	geom_area(colour = NA, alpha = 0.7) +
	scale_fill_manual(values = type_colors) +
	geom_line(
		position = "stack",
		size = 0.2
	) +
	labs(
		x = x_title,
		y = y_title,
		fill = legend_title
	) +
	guides(
		fill = guide_legend(
			reverse = FALSE,
			override.aes = list(
				alpha = 0.7,
				color = NA,
				shape = NA
			)
		),
		color = FALSE
	) +
	scale_x_continuous(
		breaks = seq(year_start, year_end, by = 1),
		labels = seq(year_start, year_end, by = 1),
		limits = c(year_start, year_end)
	) +
	scale_y_continuous(
		label = scales::label_number(suffix = " km")
	) +
	theme_minimal() +
	theme(
		plot.margin = unit(c(5,5,5,5), "points")
	)
	
	# Add title
	if (title_underline) {
		out <- out + ggtitle(
			bquote(underline(.(title)))
		)
	} else {
		out <- out + ggtitle(title)
	}
	
	# Add dotted year ref line
	if (line_year) {
		out <- out + geom_vline(
			xintercept = line_year,
			color = "black",
			linetype = "dashed"
		)
	}
	
	# Add red 50km ref line
	if (line_50km) {
		out <- out + geom_segment( # 50km red line
			aes(
				x = 2009,
				y = 0,
				xend = 2009,
				yend = 50,
				color = "#bb0000",
				hjust = 0.15
			)
		) +
		geom_segment( # 50km red triangle point down
			aes(
				x = 2009,
				y = 50.01 - (len_max * 0.05),
				xend = 2009,
				yend = 50 - (len_max * 0.05),
				color = "#bb0000",
				hjust = 0.15
			),
			arrow = arrow(
				length = unit(0.03, "npc"),
				ends = "last",
				type = "closed"
			)
		) +
		geom_segment( # 50km red triangle point up
			aes(
				x = 2009,
				y = (len_max * 0.05) - 0.01,
				xend = 2009,
				yend = (len_max * 0.05),
				color = "#bb0000",
				hjust = 0.15
			),
			arrow = arrow(
				length = unit(0.03, "npc"),
				ends = "last",
				type = "closed"
			)
		) +
		annotate(
			"text",
			x = 2009,
			y = 50,
			label = "50km",
			color = "#bb0000",
			hjust = -0.225
		)
	}
	return(out)
}
```

### Plot Lengths by Year for Infrastructure Types

Plots an area chart showing the cumulative road lengths by infrastructure type for each year.

This uses and wraps around the `plot_yearly_len` function.

```{r}

#' Plot Yearly Road Lengths By Infrastructure Type
#'
#' @param ... Arguments passed to plot_yearly_len.
#' @return An area ggplot of the cumulative yearly road lengths by road type.
#' @export
#'
plot_yearly_len_infra <- function(
		...,
		year_start = 2009,
        year_end = 2022,
		type_col = "infra_type",
		type_filter = c("N", "None", "SR"),
        type_recode = c(
        	PBL = "Cycle Track",
        	BUF = "Buffered Lane",
        	PL = "Painted Lane",
        	LSB = "Local Street\nBikeway"
        ),
		legend_title = "Infrastructure Type",
		line_50km = TRUE,
        line_year = 2019
	) {
	out <- plot_yearly_len(
		...,
		year_start = year_start,
		year_end = year_end,
		type_filter = type_filter,
		type_col = type_col,
		type_recode = type_recode,
		legend_title = legend_title,
		line_50km = line_50km,
		line_year = line_year
	)
	return(out)
}
```

### Plot Lengths by Year for Road Types

Plots an area chart showing the cumulative road lengths by road type for each year.

This uses and wraps around the `plot_yearly_len` function.

```{r}

#' Plot Yearly Road Lengths By Road Type
#'
#' @param ... Arguments passed to plot_yearly_len.
#' @return An area ggplot of the cumulative yearly road lengths by road type.
#' @export
#'
plot_yearly_len_road <- function(
		...,
		year_col = "install_year",
		year_start = 2009,
        year_end = 2022,
		x_title = sprintf("Years (%s-%s)", year_start, year_end),
		y_title = "Total Length (Centreline km)",
		legend_title = "Roadway Type",
		type_col = "road_type",
		type_recode = c(
        	Arterial = "Arterial",
        	Collector = "Collector",
        	Local = "Local"
        ),
		len_col = "len",
		line_50km = FALSE,
		line_year = 2019,
        color_low = "#C1DDB3",
        color_high = "#297A22"
	) {
	out <- plot_yearly_len(
		...,
		year_col = year_col,
		year_start = year_start,
		year_end = year_end,
		x_title = x_title,
		y_title = y_title,
		legend_title = legend_title,
		type_col = type_col,
		type_recode = type_recode,
		len_col = len_col,
		line_50km = line_50km,
		line_year = line_year,
        color_low = color_low,
        color_high = color_high
	)
	return(out)
}
```

# Data

## Vancouver Data

```{r vanc-data}

# Load raw data
vanc_bikeways <- read_csv("../data/vancouver_bikeways_2009_2022_v1.csv")
vanc_roads <- read_csv("../data/vancouver_roads_2009_2022_v1.csv")

# Combine raw data
vanc <- vanc_bikeways %>%
	select(
		ID_DATAENTRY,
		INST_YR,
		INST_MIN_HTYPE,
		UPGR1_YR,
		UPGR1_MIN_HTYPE,
		UPGR2_YR,
		UPGR2_MIN_TYPE,
		ATR_SEGMENT_LENGTH
	) %>%
	left_join(
		vanc_roads %>% select(
			ID_DATAENTRY,
			ATR_SEGMENT_TYPE
		),
		by = "ID_DATAENTRY"
	) %>%
	rename(
		id = ID_DATAENTRY,
		install_year = INST_YR,
		install_type = INST_MIN_HTYPE,
		upgrade1_year = UPGR1_YR,
		upgrade1_type = UPGR1_MIN_HTYPE,
		upgrade2_year = UPGR2_YR,
		upgrade2_type = UPGR2_MIN_TYPE,
		segment_len = ATR_SEGMENT_LENGTH,
		segment_type = ATR_SEGMENT_TYPE
	) %>%
	mutate(
		segment_len = segment_len / 1000
	)
vanc
```
## Calgary Data

```{r calg-data}

# Load raw data
calg_bikeways <- read_csv("../data/calgary_bikeways_2009_2022_v1.csv")
calg_roads <- read_csv("../data/calgary_roads_2009_2022_v1.csv")

# Combine raw data
calg <- calg_bikeways %>%
    select(
		SHAPE_ID,
		INST_YR,
		INST_MIN_HTYPE,
		UPGR1_YR,
		UPGR1_MIN_HTYPE,
		UPGR2_YR,
		UPGR2_MIN_HTYPE,
		ATR_SEGMENT_LENGTH
	) %>%
	left_join(
		calg_roads %>% select(
			shape_id,
			ctp_class
		),
		by = join_by(SHAPE_ID == shape_id)
	) %>%
	rename(
		id = SHAPE_ID,
		install_year = INST_YR,
		install_type = INST_MIN_HTYPE,
		upgrade1_year = UPGR1_YR,
		upgrade1_type = UPGR1_MIN_HTYPE,
		upgrade2_year = UPGR2_YR,
		upgrade2_type = UPGR2_MIN_HTYPE,
		segment_len = ATR_SEGMENT_LENGTH,
		segment_type = ctp_class
	) %>%
	mutate(
		segment_len = segment_len / 1000
	)
calg
```

## Toronto Data

```{r toron-data}

# Load raw data
toron_bikeways <- read_csv("../data/toronto_bikeways_2009_2022_v1.csv")
toron_roads <- read_csv("../data/toronto_roads_2009_2022_v1.csv")

# Combine raw data
toron <- toron_bikeways %>%
    select(
		ID_OID,
		INST_YR,
		INST_MIN_HTYPE,
		UPGR1_YR,
		UPGR1_MIN_HTYPE,
		UPGR2_YR,
		UPGR2_MIN_HTYPE,
		ATR_SEGMENT_LENGTH
    ) %>%
	left_join(
		toron_roads %>% select(
			OID_,
			FEATURE36
		),
		by = join_by(ID_OID == OID_)
	) %>%
	rename(
		id = ID_OID,
		install_year = INST_YR,
		install_type = INST_MIN_HTYPE,
		upgrade1_year = UPGR1_YR,
		upgrade1_type = UPGR1_MIN_HTYPE,
		upgrade2_year = UPGR2_YR,
		upgrade2_type = UPGR2_MIN_HTYPE,
		segment_len = ATR_SEGMENT_LENGTH,
		segment_type = FEATURE36
	) %>%
	mutate(
		segment_len = segment_len / 1000
	)
toron
```

# Figures

## Figure 2: Changes in dedicated cycling infrastructure between 2009 and 2022 for Vancouver, Calgary, and Toronto by infrastructure category.

Assessed using roadway centreline-km, with infrastructure classifications determined by the most protective element present along each road segment.

```{r fig.width=8.5, fig.height=11}

# Vanc plot
vanc_plot_infra <- calc_yearly_adj_len(vanc, type_col = "infra_type") %>%
    plot_yearly_len_infra(title = "Vancouver, Canada") +
    theme(plot.margin = unit(c(15, 5, 5, 5), "point"))

# Calg plot
calg_plot_infra <- calc_yearly_adj_len(calg, type_col = "infra_type") %>%
    plot_yearly_len_infra(title = "Calgary, Canada")

# Toron plot
toron_plot_infra <-  calc_yearly_adj_len(toron, type_col = "infra_type") %>%
    plot_yearly_len_infra(title = "Toronto, Canada")

# Plot for all cities
grid.arrange(
    vanc_plot_infra,
    calg_plot_infra,
    toron_plot_infra,
    ncol = 1,
    top = textGrob(
        "Roadways with Dedicated Cycling Infrastructure",
        gp = gpar(fontsize=18)
    ),
    bottom = textGrob(
        "Years (2009-2022)",
        gp = gpar(fontsize=14)
    ),
    left = textGrob(
        "Total Length (Centreline km)",
        gp = gpar(fontsize=14),
        rot = 90
    ),
    vp = viewport(
        width = 0.95,
        height = 0.95
    )
)
```

# Supplementary Figures

## Supplementary Figure 4: Changes in dedicated cycling infrastructure between 2009 and 2021 for the Municipality of Vancouver, CA

By (A) roadway classification, and (B) infrastructure distribution within each road class. Assessed using roadway centreline-km, with infrastructure classification determined by the most protective element present along each road segment.

```{r}

# Recode segments to one of art, coll, or lane
vanc_prep_roads <- vanc %>%
    mutate(road_type = case_when(
        segment_type %in% c( # arterial equiv
        	"Arterial"
        ) ~ "Arterial",
        segment_type %in% c( # collector equiv
        	"Collector",
        	"Secondary Arterial",
        	"Sec Arterial"
        ) ~ "Collector",
        segment_type %in% c( # local equiv
        	"Lane",
        	"Residential",
        	"Leased",
        	"Recreational"
        ) ~ "Local",
        .default = segment_type
    ))

# Plot
vanc_plot_roads <- calc_yearly_len(
	vanc_prep_roads,
	year_col = "install_year",
	type_col = "road_type"
) %>%
    plot_yearly_len_road(
    	title = "Roadways with Dedicated Cycling Infrastructure (Vancouver, CA)",
    	title_underline = FALSE
    )
vanc_plot_roads
```

## Calgary, CA

```{r}

# Recode segments to one of art, coll, or lane
calg_prep_roads <- calg %>%
    mutate(road_type = case_when(
        segment_type %in% c( # arterial equiv
        	"Arterial Street",
        	"Industrial Arterial",
        	"Local Arterial",
        	"Parkway",
        	"Urban Boulevard"
        ) ~ "Arterial",
        segment_type %in% c( # collector equiv
        	"Neighbourhood Boulevard",
        	"Collector",
        	"Primary Collector",
        	"Skeletal Road"
        ) ~ "Collector",
        segment_type %in% c( # local equiv
        	"Access Route",
        	"Residential Street",
        	"Activity Center Street",
        	"Historic Road Allowance",
        	"Lanes (Alleys)",
        	"Industrial Street"
        ) ~ "Local",
        .default = segment_type
    ))

# Aggregate by year
calg_plot_roads <- calc_yearly_len(
	calg_prep_roads,
	year_col = "install_year",
	type_col = "road_type"
) %>%
    plot_yearly_len_road
calg_plot_roads
```

## Toronto, CA

```{r}

# Recode segments to one of art, coll, or lane
toron_prep_roads <- toron %>%
    mutate(road_type = case_when(
        segment_type %in% c( # arterial equiv
        	"Major Arterial",
        	"Major Arterial Ramp",
        	"Minor Arterial"
        ) ~ "Arterial",
        segment_type %in% c( # collector equiv
        	"Collector"
        ) ~ "Collector",
        segment_type %in% c(  # local equiv
        	"Local",
        	"Other"
        ) ~ "Local",
        .default = segment_type
    ))

# Aggregate by year
toron_plot_roads <- calc_yearly_len(
	toron_prep_roads,
	year_col = "install_year",
	type_col = "road_type"
) %>%
    plot_yearly_len_road
toron_plot_roads
```

# Appendix

## R Version

R and RMarkdown in RStudio was used to generate this document.

```{r echo=FALSE}
version
```

## R Code

The R script below runs all the code in this document.

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```
